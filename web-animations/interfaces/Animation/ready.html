<!DOCTYPE html>
<meta charset=utf-8>
<title>Animation.ready</title>
<link rel="help" href="https://w3c.github.io/web-animations/#dom-animation-ready">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../../testcommon.js"></script>
<body>
<div id="log"></div>
<script>
"use strict";

promise_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate({}, 100 * MS_PER_SEC);
  var originalReadyPromise = animation.ready;
  var pauseReadyPromise;

  return animation.ready.then(function() {
    assert_equals(animation.ready, originalReadyPromise,
                  'Ready promise is the same object when playing completes');
    animation.pause();
    assert_not_equals(animation.ready, originalReadyPromise,
                      'A new ready promise is created when pausing');
    pauseReadyPromise = animation.ready;
    // Wait for the promise to fulfill since if we abort the pause the ready
    // promise object is reused.
    return animation.ready;
  }).then(function() {
    animation.play();
    assert_not_equals(animation.ready, pauseReadyPromise,
                      'A new ready promise is created when playing');
  });
}, 'A new ready promise is created when play()/pause() is called');

promise_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate({}, 100 * MS_PER_SEC);

  return animation.ready.then(function() {
    var promiseBeforeCallingPlay = animation.ready;
    animation.play();
    assert_equals(animation.ready, promiseBeforeCallingPlay,
                  'Ready promise has same object identity after redundant call'
                  + ' to play()');
  });
}, 'Redundant calls to play() do not generate new ready promise objects');

promise_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate({}, 100 * MS_PER_SEC);

  return animation.ready.then(function(resolvedAnimation) {
    assert_equals(resolvedAnimation, animation,
                  'Object identity of Animation passed to Promise callback'
                  + ' matches the Animation object owning the Promise');
  });
}, 'The ready promise is fulfilled with its Animation');

promise_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate({}, 100 * MS_PER_SEC);

  var retPromise = animation.ready.then(function() {
    assert_unreached('ready promise was fulfilled');
  }).catch(function(err) {
    assert_equals(err.name, 'AbortError',
                  'ready promise is rejected with AbortError');
  });

  animation.cancel();

  return retPromise;
}, 'ready promise is rejected when a play-pending animation is cancelled by'
   + ' calling cancel()');

promise_test(function(t) {
  var div = createDiv(t);
  var animation = div.animate({}, 100 * MS_PER_SEC);
  return animation.ready.then(function() {
    animation.pause();
    // Set up listeners on pause-pending ready promise
    var retPromise = animation.ready.then(function() {
      assert_unreached('ready promise was fulfilled');
    }).catch(function(err) {
      assert_equals(err.name, 'AbortError',
                    'ready promise is rejected with AbortError');
    });
    animation.cancel();
    return retPromise;
  });
}, 'ready promise is rejected when a pause-pending animation is cancelled by'
   + ' calling cancel()');

test(function(t) {
  var animation = createDiv(t).animate([], 100000);
  assert_true(animation.ready instanceof Promise);
}, 'The ready attribute should be a Promise');

async_test(function(t) {
  var animation = createDiv(t).animate([], 100000);
  animation.cancel();
  animation.ready.then(function(p) {
    t.step(function() {
      assert_equals(p, animation);
    });
    t.done();
  });
}, 'The ready promise should be resolved when an animation is in the idle play state');

test(function(t) {
  var animation = createDiv(t).animate([], 100000);
  var promise = animation.ready;
  animation.cancel();
  assert_not_equals(animation.ready, promise);
}, 'The ready promise should be replaced when the animation is cancelled');

test(function(t) {
  var animation = createDiv(t).animate([], 100000);
  animation.cancel();
  var promise = animation.ready;
  animation.play();
  assert_not_equals(animation.ready, promise);
}, 'The ready promise should be replaced when the animation enters the pending state');

async_test(function(t) {
  var animation = createDiv(t).animate([], 100000);
  animation.ready.then(function() {
    t.step(function() {
      assert_unreached();
    });
  }, function(e) {
    t.step(function() {
      assert_equals(e.code, DOMException.ABORT_ERR);
    });
    t.done();
  });
  animation.cancel();
}, 'A pending ready promise should be rejected when the animation is cancelled');

async_test(function(t) {
  var animation = createDiv(t).animate([], 100000);
  var promise = animation.ready;
  promise.then(function(p) {
    t.step(function() {
      assert_equals(p, animation);
      assert_equals(animation.ready, promise);
    });
    t.done();
  });
}, 'A pending ready promise should be resolved and not replaced when the animation enters the running state');

async_test(function(t) {
  var animation = createDiv(t).animate([], 100000);
  var promise = animation.ready;
  animation.finish();
  promise.then(function(p) {
    t.step(function() {
      assert_equals(p, animation);
      assert_equals(animation.ready, promise);
    });
    t.done();
  });
}, 'A pending ready promise should be resolved and not replaced when the animation enters the finished state');

async_test(function(t) {
  var animation = createDiv(t).animate([], 100000);
  var promise = animation.ready;
  animation.pause();
  promise.then(function(p) {
    t.step(function() {
      assert_equals(p, animation);
      assert_equals(animation.ready, promise);
    });
    t.done();
  });
}, 'A pending ready promise should be resolved and not replaced when the animation enters the paused state');

</script>
</body>
